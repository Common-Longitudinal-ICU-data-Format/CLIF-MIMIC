"""Tests for the organism mapping algorithm.

This module tests the programmatic mapping of MIMIC organism names to CLIF
organism categories, validating against manually reviewed ground truth data.
"""
import pytest
import pandas as pd
from pathlib import Path


# --- Helper Fixtures for CSV Loading ---
@pytest.fixture
def load_fixture_csv():
    """Load CSV fixture from tests/fixtures/.

    Returns
    -------
    callable
        Function that loads CSV files from the fixture directory.
    """
    def _load(filename) -> pd.DataFrame:
        path = Path(__file__).parent / 'fixtures' / filename
        df = pd.read_csv(path)
        return df
    return _load


@pytest.fixture
def validated_mappings(load_fixture_csv):
    """Load validated organism mapping ground truth.

    The validated column has three possible values:
    - 1: The mapping is correct
    - <category_name>: The current mapping is wrong, should be this category
    - empty: Not yet validated, ignored in tests

    Returns
    -------
    pd.DataFrame
        Rows where validated is not empty (either 1 or a category name).
    """
    df = load_fixture_csv('mimic-to-clif-mappings - microbiology_culture.csv')
    # Filter to only rows with validated values
    df = df[df['validated'].notna() & (df['validated'] != '')]
    return df


@pytest.fixture
def organism_mapping(load_fixture_csv):
    """Load the programmatic organism mapping result.

    This should be regenerated by running the mapping algorithm in
    dev/micro_c_dev.py and saved to data/mappings/.

    Returns
    -------
    pd.DataFrame
        The organism_mapping result from the matching algorithm.
    """
    path = Path(__file__).parent.parent / 'data' / 'mappings' / 'mimic-to-clif-mappings - microbiology_culture.csv'
    df = pd.read_csv(path)
    return df


# ===========================================
# Tests for organism mapping validation
# ===========================================
def test_correct_mappings(organism_mapping, validated_mappings):
    """Test that validated=1 rows appear correctly in organism_mapping.

    For each row where validated=1, verify that:
    - The organism_name exists in organism_mapping
    - It maps to the expected organism_category

    Parameters
    ----------
    organism_mapping : pd.DataFrame
        The programmatic mapping result.
    validated_mappings : pd.DataFrame
        Ground truth with validated column.
    """
    # Filter to correct mappings (validated == 1 or validated == "1")
    correct = validated_mappings[validated_mappings['validated'].astype(str) == '1']

    errors = []
    for _, row in correct.iterrows():
        org_name = row['organism_name']
        expected_category = row['organism_category']

        # Find this organism_name in the mapping
        matches = organism_mapping[organism_mapping['organism_name'] == org_name]

        if len(matches) == 0:
            # Handle NULL organism names (which appear as NaN)
            if pd.isna(org_name):
                matches = organism_mapping[organism_mapping['organism_name'].isna()]

        if len(matches) == 0:
            errors.append(f"Missing organism_name: {org_name}")
            continue

        actual_category = matches.iloc[0]['organism_category']
        if actual_category != expected_category:
            errors.append(
                f"Wrong mapping for '{org_name}': "
                f"expected '{expected_category}', got '{actual_category}'"
            )

    if errors:
        error_msg = "\n".join(errors[:20])  # Limit to first 20 errors
        if len(errors) > 20:
            error_msg += f"\n... and {len(errors) - 20} more errors"
        pytest.fail(f"Mapping validation failed:\n{error_msg}")


def test_incorrect_mappings_corrected(organism_mapping, validated_mappings):
    """Test that validated=<category> rows are NOT mapped to wrong category.

    For each row where validated is a category name (not 1, not empty),
    verify that the organism_name is NOT mapped to the wrong category shown
    in organism_category column.

    Parameters
    ----------
    organism_mapping : pd.DataFrame
        The programmatic mapping result.
    validated_mappings : pd.DataFrame
        Ground truth with validated column.
    """
    # Filter to rows where validated is a category name (not 1)
    incorrect = validated_mappings[
        (validated_mappings['validated'].astype(str) != '1') &
        (validated_mappings['validated'].notna())
    ]

    errors = []
    for _, row in incorrect.iterrows():
        org_name = row['organism_name']
        wrong_category = row['organism_category']
        expected_category = row['validated']

        # Find this organism_name in the mapping
        matches = organism_mapping[organism_mapping['organism_name'] == org_name]

        if len(matches) == 0:
            continue  # Can't check if not in mapping

        actual_category = matches.iloc[0]['organism_category']

        # The actual category should NOT be the wrong category
        if actual_category == wrong_category:
            errors.append(
                f"Still mapped to wrong category for '{org_name}': "
                f"got '{actual_category}', should be '{expected_category}'"
            )

        # Ideally, actual should equal expected, but we're lenient here
        # since the algorithm might have improved to a different valid category

    if errors:
        error_msg = "\n".join(errors[:20])
        if len(errors) > 20:
            error_msg += f"\n... and {len(errors) - 20} more errors"
        pytest.fail(f"Incorrect mappings not fixed:\n{error_msg}")


def test_all_categories_covered(organism_mapping):
    """Test that all 542 CLIF organism categories appear in the mapping.

    The mapping should include all categories, with NOT_AVAILABLE for those
    without matching source organism names.

    Parameters
    ----------
    organism_mapping : pd.DataFrame
        The programmatic mapping result.
    """
    # Exclude NO_MAPPING (placeholder for unmatched sources)
    real_categories = organism_mapping[
        organism_mapping['organism_category'] != 'NO_MAPPING'
    ]['organism_category'].nunique()

    # Load the CLIF categories to get expected count
    clif_path = Path(__file__).parent.parent / 'data' / 'mcide' / 'clif_microbiology_culture_organism_categories.csv'
    clif_categories = pd.read_csv(clif_path)
    expected_count = clif_categories['organism_category'].nunique()

    assert real_categories == expected_count, \
        f"Expected {expected_count} categories, got {real_categories}"
